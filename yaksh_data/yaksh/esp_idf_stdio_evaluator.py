"""
ESP-IDF StdIO Evaluator for Yaksh
"""
import os
import shutil
import subprocess
from yaksh.base_evaluator import BaseEvaluator

class EspIdfStdIOEvaluator(BaseEvaluator):
    """
    Evaluator for ESP-IDF code using QEMU and arduino_to_esp/ino_to_running.sh
    """
    def __init__(self, metadata, test_case_data):
        self.files = []
        # Ensure paths resolve to /Sites/online_test/... inside container
        base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
        yaksh_dir = os.path.join(base_dir, 'yaksh')
        arduino_to_esp_dir = os.path.join(yaksh_dir, 'arduino_to_esp')
        self.script_path = os.path.join(arduino_to_esp_dir, 'ino_to_running.sh')
        self.output_file = os.path.join(arduino_to_esp_dir, 'filtered_output.txt')
        self.timeout = 20  # seconds, can be set from settings if needed

        # Set metadata values
        self.user_answer = metadata.get('user_answer')
        self.file_paths = metadata.get('file_paths')
        self.partial_grading = metadata.get('partial_grading')

        # Set test case data values
        self.expected_input = test_case_data.get('expected_input')
        self.expected_output = test_case_data.get('expected_output')
        self.weight = test_case_data.get('weight')
        self.hidden = test_case_data.get('hidden')

    def teardown(self):
        # No temp files to delete for now, but keep for interface compatibility
        pass

    def compile_code(self):
        # Write user code to temp .ino file in arduino_to_esp
        # Use the same arduino_to_esp_dir as above
        base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
        yaksh_dir = os.path.join(base_dir, 'yaksh')
        arduino_to_esp_dir = os.path.join(yaksh_dir, 'arduino_to_esp')
        ino_file = os.path.join(arduino_to_esp_dir, 'submission.ino')
        with open(ino_file, 'w') as f:
            f.write(self.user_answer)

        # Remove previous output file if exists
        if os.path.exists(self.output_file):
            os.remove(self.output_file)

        # Run the script from arduino_to_esp directory
        try:
            proc = subprocess.run([
                'bash', self.script_path, ino_file
            ], cwd=arduino_to_esp_dir,
               stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=self.timeout)
        except subprocess.TimeoutExpired:
            self.output_value = ''
            return False, 'Timeout: Code execution exceeded time limit.'
        
        except Exception as e:
            self.output_value = ''
            return False, f'Error running evaluator: {str(e)}'

        # Check for build/run errors
        if proc.returncode != 0:
            self.output_value = ''
            stderr = proc.stderr.decode('utf-8')
            stdout = proc.stdout.decode('utf-8')
            error_msg = "Script failed with exit code {}.\nSTDERR:\n{}\nSTDOUT:\n{}".format(proc.returncode, stderr, stdout)
            with open(ino_file, 'w') as f:
                f.write(error_msg)
            return False, error_msg

        # Read filtered output
        if not os.path.exists(self.output_file):
            self.output_value = ''
            return False, 'No output generated by QEMU.'
        with open(self.output_file, 'r') as f:
            self.output_value = f.read()
        return True, None

    def check_code(self):
        # Compare output (ignore whitespace)
        def normalize(s):
            return '\n'.join(line.strip() for line in s.strip().splitlines() if line.strip())
        actual = normalize(self.output_value)
        expected = normalize(self.expected_output)
        is_correct = actual == expected
        mark_fraction = self.weight
        # return (is_correct, mark_fraction,actual)
        return is_correct, (None if is_correct else 'Output does not match.'), mark_fraction
